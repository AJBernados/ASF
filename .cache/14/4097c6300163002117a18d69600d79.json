{"id":"C7HB","dependencies":[{"name":"C:\\Users\\Anemo\\Documents\\Projects\\Blog Posts\\19_0325_StickImageEffect_codrops\\Code\\CodropsTemplate\\package.json","includedInParent":true,"mtime":1553717506836}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.vertex=exports.fragment=void 0;var e=\"\\nuniform vec2 u_resolution;\\n\\nuniform sampler2D u_texture;\\nuniform sampler2D u_texture2;\\nuniform vec2 u_textureFactor;\\nuniform vec2 u_texture2Factor;\\nuniform float u_textureProgress;\\n\\n// RGB\\nuniform vec2 u_rgbPosition;\\nuniform vec2 u_rgbVelocity;\\n\\nvarying float zz;\\nvarying vec2 vUv;\\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\\n    return uvs * factor - factor /2. + 0.5;\\n}\\nvoid main(){\\n    // On THREE 102 The image is has Y backwards\\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\\n\\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \\n\\n    \\n    vec2 vel = u_rgbVelocity;\\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\\n\\n    float ratio = clamp(1.0 - dist * 10., 0., 1.);\\n\\n\\n    vec4 tex1 = vec4(1.);\\n    vec4 tex2 = vec4(1.);\\n\\n    vec2 uv = vUv;\\n\\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\\n\\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\\n\\n    \\n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\\n\\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\\n    \\n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\\n\\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\\n     \\n    \\n\\n\\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\\n    \\n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\\n\\n    gl_FragColor = mixedTextures;\\n    // gl_FragColor = vec4(\\n    //     normalizedRgbPos.x,\\n    //     vel.y / u_resolution.x,\\n    //     0.,\\n    //     1.);\\n}\\n\";exports.fragment=e;var n=\"\\nuniform float u_viewSize;\\nuniform float u_progress;\\nuniform float u_direction;\\nuniform float u_time;\\nuniform float u_effect;\\nuniform float u_waveIntensity;\\nvarying vec2 vUv;\\nvarying float zz;\\nvoid main(){\\n    vec3 pos = position.xyz;\\n    float zChange = 0.;\\n\\n    float distance = length(position.xy );\\n    float sizeDist = length(vec2(u_viewSize)) /2.;\\n    float normalized = distance/sizeDist;\\n\\n    float stickyness = 0.5;\\n\\n    float inside = -1.+normalized;\\n    float outside = -normalized;\\n\\n    float pp = 0.;\\n    float dir = 1.;\\n    float effect = 0.;\\n\\n    pp = u_progress;\\n    dir = u_direction;\\n    effect = u_effect;\\n\\n    float eff = clamp(effect-0.5,0.,1.);\\n    float eff2 = clamp(-effect+0.5,0.,1.);\\n\\n\\n    // The mix cancel out at 0.5\\n    // When effect hits 1. the effects cancel out.\\n    float inMix = mix(inside,outside, clamp(effect-0.5,0.,1.) );\\n    // Not sure out works because it hits 0, maning it does not calcel out\\n    float outMix = mix(outside,inside,  clamp(effect-0.5,0.,1.) );\\n    zChange = mix(inMix,outMix, dir);\\n    // zChange = inMix;\\n\\n    // zChange = mix(inside,outside, u_progress-0.5 );\\n    // zChange = -1.+normalized ;\\n    // zChange += -normalized ;\\n\\n    // pos.z +=  distance;\\n    // pos.z -=  1.- distance;\\n    // pos.z =  pos.z - (u_viewSize - distance) ;\\n    // pos.z += 1.- distance;\\n\\n\\n    // Alright, the in animation looks great.\\n    // But the out animation is lacking because it doesn't really seems like\\n    // its getting close from the center\\n    // That happens because when going out, the progress is closing to 0\\n    // And makes the effect go away when getting closer to the screen\\n    // The idea would be to separate the progress of the effect and the progress\\n    // of the z-movement. And make the effect last a bit longer\\n\\n\\n    pos.z += zChange * pp *  9.;\\n\\n    \\n    pos.z += sin(distance * 2. - u_time * 2.)  * u_waveIntensity;\\n\\n    gl_Position =   \\n        projectionMatrix * \\n        modelViewMatrix * \\n         vec4(pos, 1.0);\\n\\n    zz = zChange;\\n    vUv = uv;\\n}\\n\";exports.vertex=n;"},"sourceMaps":{"js":{"mappings":[{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":0}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":13}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":20}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":35}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":43}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":56}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":57}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":64}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":68}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":76}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":83}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":91}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":105}},{"source":"shaders.js","original":{"line":1,"column":0},"generated":{"line":1,"column":107}},{"source":"shaders.js","name":"fragment","original":{"line":1,"column":6},"generated":{"line":1,"column":111}},{"source":"shaders.js","original":{"line":1,"column":0},"generated":{"line":1,"column":113}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":2295}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":2303}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":2312}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":2314}},{"source":"shaders.js","name":"vertex","original":{"line":74,"column":6},"generated":{"line":1,"column":2318}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":2320}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":4421}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":4429}},{"source":"shaders.js","original":{"line":74,"column":0},"generated":{"line":1,"column":4436}}],"sources":{"shaders.js":"const fragment = `\r\nuniform vec2 u_resolution;\r\n\r\nuniform sampler2D u_texture;\r\nuniform sampler2D u_texture2;\r\nuniform vec2 u_textureFactor;\r\nuniform vec2 u_texture2Factor;\r\nuniform float u_textureProgress;\r\n\r\n// RGB\r\nuniform vec2 u_rgbPosition;\r\nuniform vec2 u_rgbVelocity;\r\n\r\nvarying float zz;\r\nvarying vec2 vUv;\r\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\r\n    return uvs * factor - factor /2. + 0.5;\r\n}\r\nvoid main(){\r\n    // On THREE 102 The image is has Y backwards\r\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\r\n\r\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\r\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \r\n\r\n    \r\n    vec2 vel = u_rgbVelocity;\r\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\r\n\r\n    float ratio = clamp(1.0 - dist * 10., 0., 1.);\r\n\r\n\r\n    vec4 tex1 = vec4(1.);\r\n    vec4 tex2 = vec4(1.);\r\n\r\n    vec2 uv = vUv;\r\n\r\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\r\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\r\n\r\n    \r\n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\r\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\r\n    \r\n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\r\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\r\n     \r\n    \r\n\r\n\r\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\r\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\r\n    \r\n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\r\n\r\n    gl_FragColor = mixedTextures;\r\n    // gl_FragColor = vec4(\r\n    //     normalizedRgbPos.x,\r\n    //     vel.y / u_resolution.x,\r\n    //     0.,\r\n    //     1.);\r\n}\r\n`;\r\n\r\nconst vertex = `\r\nuniform float u_viewSize;\r\nuniform float u_progress;\r\nuniform float u_direction;\r\nuniform float u_time;\r\nuniform float u_effect;\r\nuniform float u_waveIntensity;\r\nvarying vec2 vUv;\r\nvarying float zz;\r\nvoid main(){\r\n    vec3 pos = position.xyz;\r\n    float zChange = 0.;\r\n\r\n    float distance = length(position.xy );\r\n    float sizeDist = length(vec2(u_viewSize)) /2.;\r\n    float normalized = distance/sizeDist;\r\n\r\n    float stickyness = 0.5;\r\n\r\n    float inside = -1.+normalized;\r\n    float outside = -normalized;\r\n\r\n    float pp = 0.;\r\n    float dir = 1.;\r\n    float effect = 0.;\r\n\r\n    pp = u_progress;\r\n    dir = u_direction;\r\n    effect = u_effect;\r\n\r\n    float eff = clamp(effect-0.5,0.,1.);\r\n    float eff2 = clamp(-effect+0.5,0.,1.);\r\n\r\n\r\n    // The mix cancel out at 0.5\r\n    // When effect hits 1. the effects cancel out.\r\n    float inMix = mix(inside,outside, clamp(effect-0.5,0.,1.) );\r\n    // Not sure out works because it hits 0, maning it does not calcel out\r\n    float outMix = mix(outside,inside,  clamp(effect-0.5,0.,1.) );\r\n    zChange = mix(inMix,outMix, dir);\r\n    // zChange = inMix;\r\n\r\n    // zChange = mix(inside,outside, u_progress-0.5 );\r\n    // zChange = -1.+normalized ;\r\n    // zChange += -normalized ;\r\n\r\n    // pos.z +=  distance;\r\n    // pos.z -=  1.- distance;\r\n    // pos.z =  pos.z - (u_viewSize - distance) ;\r\n    // pos.z += 1.- distance;\r\n\r\n\r\n    // Alright, the in animation looks great.\r\n    // But the out animation is lacking because it doesn't really seems like\r\n    // its getting close from the center\r\n    // That happens because when going out, the progress is closing to 0\r\n    // And makes the effect go away when getting closer to the screen\r\n    // The idea would be to separate the progress of the effect and the progress\r\n    // of the z-movement. And make the effect last a bit longer\r\n\r\n\r\n    pos.z += zChange * pp *  9.;\r\n\r\n    \r\n    pos.z += sin(distance * 2. - u_time * 2.)  * u_waveIntensity;\r\n\r\n    gl_Position =   \r\n        projectionMatrix * \r\n        modelViewMatrix * \r\n         vec4(pos, 1.0);\r\n\r\n    zz = zChange;\r\n    vUv = uv;\r\n}\r\n`;\r\n\r\nexport { fragment, vertex };\r\n"},"lineCount":null}},"error":null,"hash":"41c60cab1b4746495b7b12c9578062b3","cacheData":{"env":{}}}